```yaml
title: "[React] Don’t give up on testing when using Material UI with React"
author: "Jay Kim"
date: "2023-09-28"
source_url: "https://jskim1991.medium.com/react-dont-give-up-on-testing-when-using-material-ui-with-react-ff737969eec7"

summary:
  - MUI를 사용해도 테스트를 포기하지 말아야 한다.
  - 디자인 컴포넌트 라이브러리를 사용하면 UI 구현이 빨라지지만 테스트 가능성(testability)을 고려해야 한다.
  - 다양한 MUI 컴포넌트(TextField, Select, Button, Snackbar, Dialog, Pagination 등)를 예로 들어 기본 HTML 컴포넌트 대비 테스트 차이점을 설명한다.

sections:
  - section_title: "Background"
    content: |
      디자이너 없이 프로젝트를 수행하게 되면서 UI 구현 방식과 테스트 가능성에 대해 고민하게 됐다.  
      “Testability determines the success of a project”라는 말처럼, 테스트 가능성은 프로젝트 성공의 중요한 요소이다.
  - section_title: "Introduction to Material UI"
    content: |
      MUI는 프로덕션 수준의 UI 컴포넌트를 제공한다.  
      시각 구현이 빠르지만, 테스트 코드를 작성할 때 어떤 차이가 있는지 살펴볼 필요가 있다.  
      설치 명령 예: `npm install @mui/material @emotion/react @emotion/styled`
  - section_title: "Components"
    subsections:
      - name: "1. TextField"
        default_impl: |
          // 기본 HTML 구현
          const TextInput = () => {
            const [value, setValue] = useState("");
            return (
              <div>
                <h3>Default</h3>
                <label htmlFor="name-input">Name</label>
                <input
                  data-testid="name-input"
                  id="name-input"
                  type="text"
                  placeholder="Enter name"
                  value={value}
                  onChange={(event) => setValue(event.target.value)}
                />
              </div>
            );
          };
        default_test: |
          import { render, screen } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import TextInput from "./TextInput";
          
          describe("TextInput Tests", () => {
            it("test using placeholder text", async () => {
              render(<TextInput />);
              const input = await screen.findByPlaceholderText("Enter name");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
            it("test using label", async () => {
              render(<TextInput />);
              const input = await screen.findByLabelText("Name");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
            it("test using test id", async () => {
              render(<TextInput />);
              const input = await screen.findByTestId("name-input");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
          });
        mui_impl: |
          import { TextField } from "@mui/material";
          import { useState } from "react";
          
          const MuiTextInput = () => {
            const [value, setValue] = useState("");
            return (
              <div>
                <h3>mui TextField</h3>
                <TextField
                  inputProps={{ "data-testid": "name-input" }}
                  label="Name"
                  variant="outlined"
                  placeholder="Enter name"
                  value={value}
                  onChange={(event) => setValue(event.target.value)}
                />
              </div>
            );
          };
        mui_test: |
          import { render, screen } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import MuiTextInput from "./MuiTextInput";
          
          describe("TextInput Tests", () => {
            it("test using placeholder text", async () => {
              render(<MuiTextInput />);
              const input = await screen.findByPlaceholderText("Enter name");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
            it("test using label", async () => {
              render(<MuiTextInput />);
              const input = await screen.findByLabelText("Name");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
            it("test using test id", async () => {
              render(<MuiTextInput />);
              const input = await screen.findByTestId("name-input");
              await userEvent.type(input, "Jay");
              expect(input).toHaveValue("Jay");
            });
          });
      - name: "2. TextField as Textarea"
        content: |
          `<input>` 대신 `<textarea>`로 사용하는 경우.  
          MUI `TextField`에 `multiline` 및 `minRows` 속성을 추가하면 쉽게 구현 가능하며, 테스트 코드도 별도 변경 없이 동일하게 사용할 수 있다.
      - name: "3. Select with InputLabel"
        default_impl: |
          // 기본 HTML 구현
          const MemberDropdown = () => {
            const members = [
              { id: 1, name: "Jay" },
              { id: 2, name: "Su" },
            ];
            const [name, setName] = useState("");
            return (
              <div>
                <h3>Default</h3>
                <label htmlFor="name-select">Select Member</label>
                <select
                  id="name-select"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                >
                  <option value=""></option>
                  {members.map((m) => (
                    <option key={m.id} value={m.id}>
                      {m.name}
                    </option>
                  ))}
                </select>
              </div>
            );
          };
        default_test: |
          import { render, screen } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import MemberDropdown from "./MemberDropdown";
          
          describe("MemberDropdown Test", () => {
            it("should display label", async () => {
              render(<MemberDropdown />);
              expect(await screen.findByLabelText("Select Member")).toBeInTheDocument();
            });
            it("should display dropdown", async () => {
              render(<MemberDropdown />);
              expect(await screen.findByRole("combobox")).toBeInTheDocument();
            });
            it("should display options", async () => {
              render(<MemberDropdown />);
              expect(await screen.findByRole("option", { name: "" })).toBeInTheDocument();
              expect(screen.getByRole("option", { name: "Jay" })).toBeInTheDocument();
              expect(screen.getByRole("option", { name: "Su" })).toBeInTheDocument();
            });
            it("should display selected value", async () => {
              render(<MemberDropdown />);
              const dropdown = await screen.findByRole("combobox");
              expect(dropdown).toHaveValue("");
              await userEvent.selectOptions(dropdown, "Jay");
              expect(dropdown).toHaveValue("1");
            });
          });
        mui_impl: |
          import { FormControl, InputLabel, MenuItem, Select } from "@mui/material";
          import { useState } from "react";
          
          const MuiMemberDropdown = () => {
            const members = [
              { id: 1, name: "Jay" },
              { id: 2, name: "Su" },
            ];
            const [name, setName] = useState("");
            return (
              <div>
                <h3>mui Select</h3>
                <FormControl fullWidth={true} sx={{ width: "200px" }}>
                  <InputLabel id="name-select-label">Select Member</InputLabel>
                  <Select
                    data-testid="name-select"
                    labelId="name-select-label"
                    id="name-select"
                    label="Select Member"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                  >
                    {members.map((m) => (
                      <MenuItem key={m.id} value={m.id}>
                        {m.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </div>
            );
          };
        mui_test: |
          import { render, screen, within } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import MuiMemberDropdown from "./MuiMemberDropdown";
          
          describe("MuiMemberDropdown Test", () => {
            it("should display label", async () => {
              render(<MuiMemberDropdown />);
              expect(await screen.findByLabelText("Select Member")).toBeInTheDocument();
            });
            it("should display dropdown", async () => {
              render(<MuiMemberDropdown />);
              expect(
                within(await screen.findByTestId("name-select")).getByRole("button"),
              ).toBeInTheDocument();
            });
            it("should display options", async () => {
              render(<MuiMemberDropdown />);
              const dropdown = within(await screen.findByTestId("name-select")).getByRole("button");
              await userEvent.click(dropdown);
              expect(await screen.findByRole("option", { name: "Jay" })).toBeInTheDocument();
              expect(screen.getByRole("option", { name: "Su" })).toBeInTheDocument();
            });
            it("should display selected value", async () => {
              render(<MuiMemberDropdown />);
              const dropdown = within(await screen.findByTestId("name-select")).getByRole("button");
              await userEvent.click(dropdown);
              await userEvent.click(await screen.findByRole("option", { name: "Jay" }));
              expect(screen.getByText("Jay")).toBeInTheDocument();
            });
          });
      - name: "4. Button"
        default_impl: |
          const SimpleButton = ({ onClick }) => {
            return <button onClick={onClick}>Click Here</button>;
          };
        default_test: |
          import { render, screen, waitFor } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import SimpleButton from "./SimpleButton";
          
          describe("SimpleButton Tests", () => {
            it("should display button with text", async () => {
              render(<SimpleButton />);
              expect(await screen.findByRole("button", { name: "Click Here" })).toBeInTheDocument();
            });
            it("should execute click handler function when button is clicked", async () => {
              const mockOnClickHandler = jest.fn();
              render(<SimpleButton onClick={mockOnClickHandler} />);
              const button = await screen.findByRole("button", { name: "Click Here" });
              await userEvent.click(button);
              await waitFor(() => {
                expect(mockOnClickHandler).toHaveBeenCalled();
              });
            });
          });
        mui_impl: |
          import { Button } from "@mui/material";
          
          const MuiSimpleButton = ({ onClick }) => {
            return (
              <Button variant="outlined" color="success" onClick={onClick}>
                Click Here
              </Button>
            );
          };
        mui_test: |
          import { render, screen, waitFor } from "@testing-library/react";
          import userEvent from "@testing-library/user-event";
          import MuiSimpleButton from "./MuiSimpleButton";
          
          describe("MuiSimpleButton Tests", () => {
            it("should display button with text", async () => {
              render(<MuiSimpleButton />);
              expect(await screen.findByRole("button", { name: "Click Here" })).toBeInTheDocument();
            });
            it("should execute click handler function when button is clicked", async () => {
              const mockOnClickHandler = jest.fn();
              render(<MuiSimpleButton onClick={mockOnClickHandler} />);
              const button = await screen.findByRole("button", { name: "Click Here" });
              await userEvent.click(button);
              await waitFor(() => {
                expect(mockOnClickHandler).toHaveBeenCalled();
              });
            });
          });
      - name: "5. Snackbar & Alert"
        content: |
          MUI의 `Snackbar` 컴포넌트를 이용해 사용자의 피드백 알림을 구현하고, auto-hide 기능까지 포함한 테스트 코드 예시를 제시한다.  
          `Snackbar` 의 ARIA 역할은 `alert`이다. 테스트 시 타이머 조작(jest fake timer)을 활용한다.
      - name: "6. Dialogs"
        content: |
          `Dialog` 컴포넌트를 예로 들어 모달 오픈/클로즈 시나리오 테스트를 설명한다.  
          `dialog` 역할(role)을 활용해 접근할 수 있다.
      - name: "7. Pagination"
        content: |
          `Pagination` 컴포넌트 (테이블 + 페이지네이션 컨트롤) 사용 시 페이지 버튼이 각각 `button` 역할이며, 페이지네비게이션 역할은 `navigation` role이다.  
          API 호출(mocking) 및 페이지 전환 시 호출 인자를 검증하는 방식으로 테스트 구현한다.
  - section_title: "Conclusion"
    content: |
      MUI 덕분에 디자인 구현 속도는 빨랐고, 테스트에도 집중할 수 있었다.  
      약 1.5 개월 동안 프론트엔드 + 백엔드에서 각각 약 250개의 테스트를 작성했다.  
      디자인 디자이너 없이도 클라이언트가 만족했고, 팀은 높은 속도로 프로젝트를 진행했다.  
      테스트 가능성을 포기하지 않고 라이브러리를 활용한 좋은 사례다.

key_takeaways:
  - UI 라이브러리를 사용해도 테스트 코드를 포기해서는 안 된다.
  - 각 컴포넌트(MUI 포함)의 렌더링 방식이나 역할(role)이 기본 HTML 요소와 조금 다를 수 있다.
  - 적절한 `data-testid`, `aria-role`, `labelText`, `placeholderText` 등을 활용하라.
  - 역할(role)이나 test id가 바뀔 수 있으므로 테스트 코드를 작성하기 전에 렌더된 마크업을 확인하라.
  - 모킹(mock) 또는 타이머(fake timer)처럼 테스트 도구를 적극 활용하라.

recommendations:
  - MUI 컴포넌트(버전, 구현 방식)를 잘 이해하고, 테스트 라이브러리와의 상관관계를 먼저 파악하라.
  - 테스트 대상 컴포넌트가 내부적으로 복잡하다면 `data-testid` 나 `aria-label`을 추가해 찾기 쉽게 만들어라.
  - UI 라이브러리 업데이트 시 변경된 내부 렌더링 방식이 테스트 코드에 영향 줄 수 있으므로 주기적으로 리팩토링하라.
  - 테스트 실패가 많아지는 순간은 ‘라이브러리 사용 + 테스트 포기’ 시점이다. 라이브러리를 제대로 이해하고 테스트 가능성(testability)을 확보하라.

metadata:
  tags:
    - react
    - material-ui
    - testing
    - react-testing-library
    - ui-library

```